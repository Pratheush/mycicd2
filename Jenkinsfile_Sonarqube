pipeline {
    
  parameters {
  booleanParam(name: 'CLEANUP_ENABLED', defaultValue: true, description: 'Clean up Docker images after push')
  }
  
  // Define the agent where the pipeline will run.
  // 'any' means Jenkins will pick any available agent.
  // If you have a specific label for your Windows 11 machine (e.g., 'windows-agent'),
  // you can use 'agent { label 'windows-agent' }' instead.
  // agent { label 'windows-docker' }
  agent any
  
  tools {
    maven "maven_3_9_5"
    // make sure this name matches the configured JDK name inside Jenkins this way we can specify jdk specifically an another version for a pipeline
    // jdk "jdk21"
  }
  
  // If you don't want Jenkins to do that auto-checkout and only want to rely on your git step, you could set:  skipDefaultCheckout(true)
  // skipDefaultCheckout(false) means: Jenkins will perform the default checkout scm at the start of the pipeline.
  options {
    skipDefaultCheckout(true)
  }

  // Define environment variables.
  // IMPORTANT: Replace 'your-dockerhub-username' and 'your-repo-name'
  // The 'docker-hub-credentials' should be a 'Secret text' credential in Jenkins or UsernameAndPassword type
  // storing your Docker Hub password/token.
  environment {
    DOCKER_IMAGE_NAME = 'pratheush/spring-customer-mgmt-jenkins-cicd'
    // Stored DockerHub Credentials In Jenkins credentials ID
    DOCKER_CREDENTIALS_ID = 'dockerhub-uname-pwd-token'
    SONAR_TOKEN = credentials('jenkins-sonarqube-token')
  }

  // Define triggers for the pipeline.
  // 'githubPush()' configures the pipeline to be triggered by GitHub push events.
  triggers {
    // This allows GitHub to trigger builds on push (needs webhook configured)
    // // Ensure you have configured a GitHub webhook in your repository settings pointing to your Jenkins instance.
    githubPush()
  }

  // Define the stages of your CI/CD pipeline.
  stages {
      
    // Stage 1: Checkout Source Code 
    stage('Checkout') {
      steps {
        echo 'üì¶ Checking out source code...'
        // Checkout the SCM (Source Code Management) configured for this job. This typically points to your GitHub repository.
        git branch: 'master', url: 'https://github.com/Pratheush/mycicd2.git'
      }
    }

    // Stage 2: Build Spring Boot Application
    // FOR ONE-LINER AND SIMPLICITY WE CAN USE DIRECTLY HERE IN BUILDING AND TESTING APP :: sh 'mvn clean verify sonar:sonar -Dsonar.login=$SONAR_TOKEN'
    // FOR PRODUCTION SEPARATE STAGES ARE CONFIGURED
    stage('Build & Test App') {
      steps {
        echo 'üõ†Ô∏è Building Spring Boot application with Maven...'
        // Use 'bat' for Windows
        // 'mvn clean package' cleans the target directory and packages the application into a JAR file (typically in the 'target' directory).
        // -DskipTests to skip tests during build, remove if you want tests to run
        // bat './mvnw clean package -DskipTests'
        // bat './mvnw clean verify'
        // bat './mvnw clean package'
        sh 'mvn clean verify'
      }
    }

    // Running Unit Tests on SPringBoot Application
    stage('Test') {
      steps {
        echo 'Running Unit Tests SpringBoot Application'
        sh 'mvn test'
      }
    }

    // Running Static Code Analysis Via SonarQube
    stage('SonarQube Analysis') {
      steps {
        echo 'Going to Run static code analysis SpringBoot Application'
        withSonarQubeEnv(installationName: 'sonarqube') {
          echo 'Starting Running STATIC CODE ANALYSIS on SPRINGBOOT APPLICATION....'  
          // Below here Default Sonar configured and specified in Jenkins would be used
          // sh 'mvn verify sonar:sonar -Dsonar.login=$SONAR_TOKEN'
          // Below here specifying which sonar maven version plugin should be used
          //sh 'mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.9.0.2155:sonar -Dsonar.login=$SONAR_TOKEN'

          // as -Dsonar.login has been deprecated we use -Dsonar.token instead
          // sh 'mvn verify sonar:sonar -Dsonar.token=$SONAR_TOKEN'

          // Tell SonarQube Where to Find the Report Update SonarQube analysis stage like this: 
          // sh 'mvn verify sonar:sonar -Dsonar.token=$SONAR_TOKEN -Dsonar.projectKey=mycicd2 -Dsonar.host.url=http://localhost:9000 -Dsonar.junit.reportPaths=target/surefire-reports,target/failsafe-reports -Dsonar.coverage.jacoco.xmlReportPaths=target/jacoco-report/jacoco.xml'
          sh 'mvn sonar:sonar -Dsonar.token=$SONAR_TOKEN -Dsonar.projectKey=customer-mgmt-jenkins-projectKey -Dsonar.projectName=customer-mgmt-jenkins-projectName -Dsonar.projectVersion=1.0 -Dsonar.host.url=http://localhost:9000 -Dsonar.junit.reportPaths=target/surefire-reports,target/failsafe-reports -Dsonar.coverage.jacoco.xmlReportPaths=target/jacoco-report/jacoco.xml'

        }
      }
    }

    // Enable Quality Gates (Optional but Recommended)
    // we wanted to make sure a quality gate is passed 
    // In SonarQube, configure a Quality Gate , Add a webhook in SonarQube to notify Jenkins of pass/fail status
    // we are gonna get Three minutes timeout and we are gonna wait for quality-gate TO PASS/FAIL and BASED ON QUALITY-GATE if the quality-gates pass/fail . if it comes with failed quality-gate this pipeline is going to abort
    // or if quality-gate comes with pass then pipeline will continue further and succeed
    stage("Quality Gate") {
      steps {
        echo 'Quality Gate PASS/FAIL CHECK'
        timeout(time: 5, unit: 'MINUTES') {
          // waitForQualityGate abortPipeline: true
          waitForQualityGate abortPipeline: true, credentialsId: 'jenkins-sonarqube-token'
        }
      }
    }


    // Stage 3: Build Docker Image 
     stage('Build Docker Image') {
      steps {
        echo 'üê≥ Building Docker image...'
        // Build the Docker image.
        // Assumes a Dockerfile exists in the root of your project.
        // .    the current directory where Dockerfile and project file lives
        // build   command passes to batch file which builds Docker Image
        // -t     tags the image with the name from the environment variable and gives it the latest tag
        // Uses multi-tag Docker image (short-commit and latest) ‚Äî good practice.
        script {
          echo 'Building Docker image INSIDE SCRIPT SECTION'
          def shortCommit = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          def imageTag    = "${DOCKER_IMAGE_NAME}:${shortCommit}"
          def latestTag   = "${DOCKER_IMAGE_NAME}:latest"

          echo "üîñ shortCommit: ${shortCommit}"
          echo "üì∏ imageTag: ${imageTag}"
          echo "üÜï latestTag: ${latestTag}"
          
          sh "docker build -t ${imageTag} -t ${latestTag} ."
          
          echo ' Docker image BUILT '    
          
          // Save to environment for next stage
          env.IMAGE_TAG = imageTag
          env.LATEST_TAG = latestTag
          echo "‚úÖ Built image: ${env.IMAGE_TAG} and tagged as latest"
        }
      }
    }
    
    // This defines a named pipeline stage that focuses on pushing a built Docker image to DockerHub.
    // Inside the steps block, the script section allows you to run Groovy-based custom logic
    // DOCKER_CREDENTIALS_ID refers to the Jenkins credentials ID configured in Jenkins to store your DockerHub username/password or token. 
    // Push Docker Image to DockerHub stage using withDockerRegistry {} is more robust and secure for Windows environments:
    // - Cross-platform compatible: No piping issues like you‚Äôd face with --password-stdin.

    stage('Push Docker Image to DockerHub') {
      steps {
        echo 'üöÄ Pushing Docker image... using withCredentials : usernamePassword Way'
        withCredentials([usernamePassword(credentialsId: DOCKER_CREDENTIALS_ID,
                                          usernameVariable: 'DOCKER_USER',
                                          passwordVariable: 'DOCKER_PASS')]) {
            sh """
               echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin
               docker push ${env.IMAGE_TAG}
               docker push ${env.LATEST_TAG}
           """
        }
        echo "üöÄ Docker image ${env.IMAGE_TAG} pushed to DockerHub successfully!"
        echo "‚úÖ Tagged as latest: ${env.LATEST_TAG}"
      }
    }
    
//     stage('Push Docker Image to DockerHub') {
//       steps {
//         echo 'üîê Logging in to DockerHub using withDockerRegistry...'
//         withDockerRegistry([credentialsId: DOCKER_CREDENTIALS_ID, url: '']) {
//         //sh "docker push ${env.IMAGE_TAG}"
//         sh "docker push ${env.LATEST_TAG}"
//       }
//       echo "üöÄ Docker image ${env.IMAGE_TAG} pushed to DockerHub successfully!"
//       echo "‚úÖ Tagged as latest: ${env.LATEST_TAG}"
//     }
//    }
   
   stage('Clean Docker Images (optional)') {
      when {
        expression { params.CLEANUP_ENABLED }
      }
      steps {
        echo "üßπ Cleaning up local Docker images as cleanup is enabled..."
        script {
          def status1 = sh(script: "docker rmi ${env.IMAGE_TAG}", returnStatus: true)
          def status2 = sh(script: "docker rmi ${env.LATEST_TAG}", returnStatus: true)
          echo "üßπ Cleanup status: IMAGE_TAG=${status1}, LATEST_TAG=${status2}"
        }
      }
   }

    
  }

  // Uses cleanWs() in post block ‚Äî clean workspace ensures clean builds
  // cleanWs() is a predefined method provided by the Workspace Cleanup Plugin in Jenkins. It‚Äôs specifically designed for use in Declarative Pipelines, and you‚Äôre using it perfectly in the post section to clean up the workspace after every build.
  // Define post-build actions, e.g., send notifications. 
  post {
    always {

      junit '**/surefire-reports/*.xml, **/failsafe-reports/*.xml'
      // jacoco() is not available method since jacoco plugin is not installed in jenkins as jacoco plugin is depracted
      //recordCoverage tools: [jacoco()]
      // publishCoverage adapters: [jacocoAdapter('target/jacoco-report/jacoco.xml')], sourceFileResolver: sourceFiles('STORE_LAST_BUILD')
      recordCoverage(tools: [[parser: 'JACOCO', pattern: 'target/jacoco-report/jacoco.xml']], sourceDirectories: [[path: 'src/main/java']])

      echo "üèÅ Cleaning Workspace."
      cleanWs()
      echo "üèÅ Pipeline execution finished."
      // You can add more post-build actions here, e.g., email notifications, Slack messages.
      // For example:
      // mail to: 'your-email@example.com',
      //      subject: "Jenkins Build ${currentBuild.displayName}: ${currentBuild.currentResult}",
      //      body: "Build ${currentBuild.displayName} (${env.BUILD_URL}) finished with status ${currentBuild.currentResult}"
    }
    success {
      echo '‚úÖ Pipeline executed successfully.'
      echo 'üöÄ Docker image successfully built and pushed!'
    }
    failure {
      echo "‚ùå CI/CD Pipeline failed!"
    }
  }
}